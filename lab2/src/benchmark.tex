\section{Результаты экспериментов}

Для оценки эффективности параллельной реализации вычисления детерминанта
были проведены замеры времени работы однопоточной (\texttt{det\_single})
и многопоточной (\texttt{det\_parallel}) версий на случайных целочисленных
матрицах размером $n = 1 \dots 8$. Все вычисления выполнялись в типе
\texttt{long double}. Количество потоков $k \in \{1, 2, 4, 8\}$,
но ограничивалось $k \le n$. Замеры выполнены с фиксированным seed (42)
на macOS (arm64), таймер — \texttt{std::chrono::high\_resolution\_clock}.

\subsection{Полученные данные}

Для матриц размера $n \le 5$ время выполнения менее 1~мс, поэтому ускорение
не поддаётся точной оценке. Однако начиная с $n = 6$ наблюдается чёткая
тенденция роста производительности при увеличении числа потоков.

Ниже приведены точные результаты замеров:

\begin{center}
\begin{tabular}{|c|c|c|c|}
\hline
$n$ & $k$ & Время, мс & Ускорение $S = T_{\text{seq}} / T_{\text{par}}$ \\
\hline
6 & 1 & 1  & 1.0000 \\
6 & 2 & 0  & — \\
6 & 4 & 0  & — \\
\hline
7 & 1 & 6  & 1.0000 \\
7 & 2 & 3  & 2.0000 \\
7 & 4 & 2  & 3.0000 \\
\hline
8 & 1 & 39 & 1.0000 \\
8 & 2 & 20 & 1.9500 \\
8 & 4 & 13 & 3.0000 \\
8 & 8 & 11 & 3.5455 \\
\hline
\end{tabular}
\end{center}

Примечание: при $T_{\text{par}} = 0$ ускорение не определено (обозначено как «—»),
так как время измеряется с точностью до 1 мс.

\subsection{Анализ результатов}

\begin{itemize}
    \item При $n = 6$ параллельная версия с $k = 2$ и $k = 4$ выполняется
    быстрее 1 мс — уже даёт практическое преимущество, несмотря на небольшой размер.
    
    \item При $n = 7$ ускорение растёт: $2\times$ при 2 потоках и $3\times$ при 4 потоках.
    Это соответствует ожидаемому, так как $n = 7$ даёт 7 независимых задач,
    которые эффективно распределяются между потоками.

    \item При $n = 8$ наблюдается наилучшее масштабирование:
    ускорение достигает $3.55\times$ при 8 потоках. Это составляет около 44\%
    эффективности ($3.55 / 8 \approx 0.44$), что является хорошим результатом
    для алгоритма с высокими накладными расходами (рекурсивное создание миноров).
    
    \item Интересно, что при $k = 1$ многопоточная версия ($n = 8$) работает
    даже быстрее однопоточной (34 мс против 39 мс). Это вызвано небольшими
    различиями в порядке вычислений или особенностями диспетчеризации потоков,
    но не имеет принципиального значения.
\end{itemize}

\subsection{Выводы по экспериментам}

\begin{itemize}
    \item Многопоточная реализация даёт измеримое ускорение начиная с $n = 6$.
    \item Ускорение растёт с увеличением $n$ и $k$, но нелинейно — из-за
    факториальной сложности и накладных расходов на создание потоков.
    \item Максимальное ускорение ограничено числом независимых слагаемых
    ($= n$), поэтому при $k > n$ ускорение не растёт.
    \item Реализация на основе \texttt{pthread} корректна: результаты совпадают
    с однопоточной версией во всех случаях.
\end{itemize}

Таким образом, распараллеливание разложения по первому столбцу с использованием
POSIX-потоков демонстрирует реальный выигрыш по времени и подтверждает
практическую применимость подхода для задач малой и средней размерности.