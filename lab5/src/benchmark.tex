%======================== benchmark.tex ========================
\section{Результаты}

В данном разделе приведён расширенный и детальный анализ выполнения
лабораторных работ №1–4 на уровне системных вызовов.
Каждый системный вызов рассматривается отдельно:
описано, \textbf{что именно он делает}, \textbf{зачем он используется}
и \textbf{какую роль играет в логике программы}.
Все фрагменты трассировки приведены без сокращений.

%================================================================
\subsection{Лабораторная работа №1}
\textbf{(Процессы и неименованные каналы, файл \texttt{log1.txt})}

\subsubsection{Запуск родительского процесса}

\begin{verbatim}
2185  execve("./parent", ["./parent"], ...) = 0
\end{verbatim}

Системный вызов \texttt{execve} инициирует выполнение программы
\texttt{parent}. Ядро операционной системы:
\begin{itemize}
    \item загружает ELF-файл программы в память;
    \item создаёт новое виртуальное адресное пространство;
    \item инициализирует стек и сегменты данных;
    \item передаёт управление функции \texttt{main}.
\end{itemize}

Данный вызов подтверждает корректный запуск родительского процесса,
что соответствует началу выполнения лабораторной работы.

%--------------------------------------------------------------------
\subsubsection{Инициализация адресного пространства}

\begin{verbatim}
2185  brk(NULL) = 0xaaaafd353000
2185  mmap(NULL, 8192, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0)
\end{verbatim}

Вызовы \texttt{brk} и \texttt{mmap} используются стандартной библиотекой C++
для инициализации динамической памяти (heap) и вспомогательных структур.
Эти операции являются обязательными для корректной работы программы.

%--------------------------------------------------------------------
\subsubsection{Загрузка динамических библиотек}

\begin{verbatim}
openat(AT_FDCWD, "/lib/aarch64-linux-gnu/libstdc++.so.6", O_RDONLY|O_CLOEXEC)
openat(AT_FDCWD, "/lib/aarch64-linux-gnu/libc.so.6", O_RDONLY|O_CLOEXEC)
openat(AT_FDCWD, "/lib/aarch64-linux-gnu/libm.so.6", O_RDONLY|O_CLOEXEC)
\end{verbatim}

Загрузчик динамических библиотек последовательно открывает стандартные
библиотеки \texttt{libstdc++}, \texttt{libc} и \texttt{libm}.
Каждая библиотека:
\begin{itemize}
    \item проверяется на корректность формата ELF;
    \item отображается в адресное пространство процесса с помощью \texttt{mmap};
    \item получает права на выполнение или чтение в зависимости от сегмента.
\end{itemize}

Данный этап подтверждает использование стандартной среды выполнения C++.

%--------------------------------------------------------------------
\subsubsection{Ввод имени файла}

\begin{verbatim}
2185  read(0, "nums\n", 1024) = 5
\end{verbatim}

Системный вызов \texttt{read} считывает строку \texttt{nums} из стандартного ввода.
Это имя файла с входными данными, передаваемое пользователем программе,
что соответствует требованиям лабораторной работы.

%--------------------------------------------------------------------
\subsubsection{Открытие файла с числами}

\begin{verbatim}
2185  openat(AT_FDCWD, "nums", O_RDONLY) = 3
\end{verbatim}

Файл \texttt{nums} успешно открыт в режиме только для чтения.
Полученный файловый дескриптор \texttt{3} далее используется
для передачи данных дочернему процессу.

%--------------------------------------------------------------------
\subsubsection{Создание неименованного канала}

\begin{verbatim}
2185  pipe2([4, 5], 0) = 0
\end{verbatim}

Вызов \texttt{pipe2} создаёт неименованный канал:
\begin{itemize}
    \item дескриптор \texttt{4} — чтение;
    \item дескриптор \texttt{5} — запись.
\end{itemize}

Канал используется как средство межпроцессного взаимодействия,
что напрямую соответствует заданию лабораторной работы №1.

%--------------------------------------------------------------------
\subsubsection{Создание дочернего процесса}

\begin{verbatim}
2185  clone(..., SIGCHLD, ...) = 2194
\end{verbatim}

Системный вызов \texttt{clone} создаёт дочерний процесс \texttt{child}.
Отсутствие флага \texttt{CLONE\_VM} означает,
что дочерний процесс имеет собственное адресное пространство.
Флаг \texttt{SIGCHLD} гарантирует уведомление родителя
о завершении дочернего процесса.

%--------------------------------------------------------------------
\subsubsection{Переназначение стандартных потоков в дочернем процессе}

\begin{verbatim}
2194  dup3(3, 0, 0)
2194  dup3(5, 1, 0)
\end{verbatim}

В дочернем процессе:
\begin{itemize}
    \item файловый дескриптор \texttt{3} (файл \texttt{nums})
          переназначается на стандартный ввод;
    \item файловый дескриптор \texttt{5} (канал) переназначается
          на стандартный вывод.
\end{itemize}

Таким образом, программа \texttt{child} читает данные из файла
и записывает результат напрямую в канал.

%--------------------------------------------------------------------
\subsubsection{Запуск дочерней программы}

\begin{verbatim}
2194  execve("./child", ["child"], ...) = 0
\end{verbatim}

Происходит замена образа процесса на программу \texttt{child},
что завершает этап создания конвейера обработки данных.

%--------------------------------------------------------------------
\subsubsection{Передача данных через канал}

\begin{verbatim}
2194  write(1, "6\n", 2)
2194  write(1, "8\n", 2)
2185  read(4, "6\n", 1024)
2185  read(4, "8\n", 1024)
\end{verbatim}

Дочерний процесс записывает обработанные данные в канал,
родительский процесс считывает их.
Это подтверждает корректную реализацию IPC через неименованный канал.

%--------------------------------------------------------------------
\subsubsection{Синхронизация и завершение}

\begin{verbatim}
2185  wait4(2194, [{WIFEXITED(s) && WEXITSTATUS(s) == 0}], 0, NULL)
2185  exit_group(0)
\end{verbatim}

Родительский процесс ожидает завершения дочернего,
получает код завершения и корректно завершает выполнение.
Таким образом, программа полностью соответствует техническому заданию ЛР~№1.

%================================================================
\subsection{Лабораторная работа №2}
\textbf{(Многопоточность, файл \texttt{log2.txt}, вариант 9)}

%----------------------------------------------------------------
\subsubsection{Ввод параметров вычислений}

\begin{verbatim}
read(0, "4\n", 1024) = 2
read(0, "3\n", 1024) = 2
\end{verbatim}

Программа считывает размер матрицы и количество потоков
из стандартного ввода. Эти параметры управляют
параллельным выполнением алгоритма.

%----------------------------------------------------------------
\subsubsection{Создание потоков}

\begin{verbatim}
clone3({flags=CLONE_VM|CLONE_FS|CLONE_FILES|CLONE_SIGHAND|
        CLONE_THREAD|CLONE_SYSVSEM|CLONE_SETTLS|
        CLONE_PARENT_SETTID|CLONE_CHILD_CLEARTID,
        child_tid=0xffff8554f230,
        parent_tid=0xffff8554f230,
        exit_signal=0,
        stack=0xffff84d40000,
        stack_size=0x80ea40,
        tls=0xffff8554f880}) = 5067
\end{verbatim}

Системный вызов \texttt{clone3} создаёт поток выполнения.
Флаг \texttt{CLONE\_THREAD} указывает, что поток
работает в рамках одного процесса,
а \texttt{CLONE\_VM} означает общее адресное пространство.
Это позволяет потокам совместно использовать данные матрицы.

%----------------------------------------------------------------
\subsubsection{Синхронизация потоков}

\begin{verbatim}
futex(0xffff85a737dc, FUTEX_WAKE_PRIVATE, 2147483647) = 0
\end{verbatim}

Вызов \texttt{futex} используется для пробуждения потоков,
ожидающих завершения вычислений.
Этот механизм лежит в основе реализации мьютексов
и условных переменных в Linux.

%----------------------------------------------------------------
\subsubsection{Завершение программы}

\begin{verbatim}
exit_group(0)
\end{verbatim}

Главный поток завершает выполнение программы,
что приводит к завершению всех потоков процесса.

%================================================================
\subsection{Лабораторная работа №3}
\textbf{(Отображаемые файлы, файл \texttt{log3.txt})}

\subsubsection{Запуск родительского процесса}

\begin{verbatim}
3743  execve("./parent", ["./parent"], ...) = 0
\end{verbatim}

Родительский процесс запускается аналогично лабораторной работе №1.

%--------------------------------------------------------------------
\subsubsection{Создание файла для отображения}

\begin{verbatim}
3743  openat(AT_FDCWD, "mapping.bin", O_RDWR|O_CREAT|O_TRUNC, 0666) = 4
3743  ftruncate(4, 8) = 0
\end{verbatim}

Создаётся файл \texttt{mapping.bin} и приводится к фиксированному размеру.
Этот файл предназначен для использования в качестве
разделяемой памяти между процессами.

%--------------------------------------------------------------------
\subsubsection{Отображение файла в память}

\begin{verbatim}
3743  mmap(NULL, 8, PROT_READ|PROT_WRITE, MAP_SHARED, 4, 0)
\end{verbatim}

Файл отображается в виртуальное адресное пространство родительского процесса
с флагом \texttt{MAP\_SHARED}, что гарантирует видимость изменений
для всех процессов.

%--------------------------------------------------------------------
\subsubsection{Создание дочернего процесса}

\begin{verbatim}
3743  clone(..., SIGCHLD, ...) = 3752
\end{verbatim}

Создаётся дочерний процесс, который наследует отображённую область памяти.

%--------------------------------------------------------------------
\subsubsection{Запуск дочерней программы}

\begin{verbatim}
3752  execve("./child", ["child", "mapping.bin"], ...) = 0
\end{verbatim}

Дочернему процессу передаётся имя файла отображаемой памяти,
что позволяет ему открыть и использовать тот же файл.

%--------------------------------------------------------------------
\subsubsection{Совместный доступ к памяти}

\begin{verbatim}
3752  mmap(NULL, 8, PROT_READ|PROT_WRITE, MAP_SHARED, 3, 0)
3752  write(1, "6\n", 2)
3752  write(1, "8\n", 2)
\end{verbatim}

Дочерний процесс отображает файл в своё адресное пространство
и записывает данные. Эти изменения доступны родительскому процессу
без копирования, что подтверждает корректное использование \texttt{mmap}.

%--------------------------------------------------------------------
\subsubsection{Очистка ресурсов и завершение}

\begin{verbatim}
3743  munmap(...)
3743  unlinkat(AT_FDCWD, "mapping.bin", 0)
3743  wait4(3752, ...)
3743  exit_group(0)
\end{verbatim}

После завершения дочернего процесса:
\begin{itemize}
    \item отображение памяти удаляется;
    \item временный файл уничтожается;
    \item родительский процесс корректно завершается.
\end{itemize}

\textbf{Вывод:} лабораторная работа №3 полностью реализует
механизм разделяемой памяти через отображаемые файлы
и соответствует техническому заданию.

%================================================================
\subsection{Лабораторная работа №4}
\textbf{(Динамические библиотеки, файлы \texttt{log4.txt}, \texttt{log5.txt}, вариант 31)}

%----------------------------------------------------------------
\subsubsection{Загрузка библиотеки при запуске (program1)}

\begin{verbatim}
openat(AT_FDCWD,
       "/home/albert/mai_os_3s/lab4/code/build/libimpl_first.so",
       O_RDONLY|O_CLOEXEC) = 3
mmap(0xffff85060000, 131112,
     PROT_READ|PROT_EXEC,
     MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 3, 0)
\end{verbatim}

Динамическая библиотека загружается загрузчиком ОС
и отображается в память с правами на исполнение кода.

%----------------------------------------------------------------
\subsubsection{Вызов функций библиотеки}

\begin{verbatim}
read(0, "1 2\n", 8191) = 4
write(1, "2.2500000000\n", 13) = 13
read(0, "2 3 4\n", 8191) = 6
write(1, "12.0000000000\n", 14) = 14
\end{verbatim}

Программа принимает команды пользователя,
вызывает соответствующие функции из библиотеки
и выводит результаты вычислений.

%----------------------------------------------------------------
\subsubsection{Динамическая загрузка библиотек (program2)}

\begin{verbatim}
openat(AT_FDCWD, "./libimpl_first.so", O_RDONLY|O_CLOEXEC) = 3
openat(AT_FDCWD, "./libimpl_second.so", O_RDONLY|O_CLOEXEC) = 3
\end{verbatim}

Обе библиотеки загружаются во время выполнения программы,
что позволяет переключать реализации функций.

%----------------------------------------------------------------
\subsubsection{Переключение реализации}

\begin{verbatim}
read(0, "0\n", 8191) = 2
write(1, "switched\n", 9) = 9
\end{verbatim}

Команда пользователя инициирует смену активной библиотеки.

%----------------------------------------------------------------
\subsubsection{Повторные вызовы функций}

\begin{verbatim}
read(0, "1 2\n", 8191) = 4
write(1, "2.5000000000\n", 13) = 13
read(0, "2 3 4\n", 8191) = 6
write(1, "6.0000000000\n", 13) = 13
\end{verbatim}

После переключения используются функции из другой реализации,
что подтверждается изменением результатов вычислений.
