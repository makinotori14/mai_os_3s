%======================== benchmark.tex ========================
\section{Результаты}

В данном разделе приведён расширенный и детальный анализ выполнения
лабораторных работ №1–4 на уровне системных вызовов.
Каждый системный вызов рассматривается отдельно:
описано, \textbf{что именно он делает}, \textbf{зачем он используется}
и \textbf{какую роль играет в логике программы}.
Все фрагменты трассировки приведены без сокращений.

%================================================================
\subsection{Лабораторная работа №1}
\textbf{(Процессы и неименованные каналы, файл \texttt{log1.txt}, вариант 10)}

%----------------------------------------------------------------
\subsubsection{Запуск программы}

\begin{verbatim}
execve("./parent", ["./parent"], 0xffffdc8b46b0 /* 56 vars */) = 0
\end{verbatim}

Системный вызов \texttt{execve} выполняет запуск программы
\texttt{parent}. Ядро операционной системы:
\begin{itemize}
    \item загружает ELF-файл программы в память;
    \item инициализирует новое адресное пространство процесса;
    \item формирует стек процесса;
    \item передаёт управление точке входа программы.
\end{itemize}
Данный вызов является началом выполнения пользовательской программы.

%----------------------------------------------------------------
\subsubsection{Чтение имени входного файла}

\begin{verbatim}
read(0, "nums\n", 1024) = 5
\end{verbatim}

Системный вызов \texttt{read} считывает данные из файлового дескриптора~0,
соответствующего стандартному потоку ввода.
Программа получает имя файла \texttt{nums}, содержащего входные данные.
Этот этап соответствует вводу параметров пользователем.

%----------------------------------------------------------------
\subsubsection{Открытие файла с входными данными}

\begin{verbatim}
openat(AT_FDCWD, "nums", O_RDONLY) = 3
\end{verbatim}

Вызов \texttt{openat} открывает файл \texttt{nums} в режиме
только для чтения. Ядро:
\begin{itemize}
    \item проверяет существование файла;
    \item проверяет права доступа;
    \item создаёт запись в таблице открытых файлов процесса.
\end{itemize}
Возвращаемый файловый дескриптор \texttt{3} используется
для дальнейшего чтения данных.

%----------------------------------------------------------------
\subsubsection{Создание неименованного канала}

\begin{verbatim}
pipe2([4, 5], 0) = 0
\end{verbatim}

Системный вызов \texttt{pipe2} создаёт неименованный канал.
Ядро выделяет буфер в памяти и возвращает два файловых дескриптора:
\begin{itemize}
    \item \texttt{4} — конец канала для чтения;
    \item \texttt{5} — конец канала для записи.
\end{itemize}
Канал используется для передачи данных от дочернего процесса
к родительскому.

%----------------------------------------------------------------
\subsubsection{Создание дочернего процесса}

\begin{verbatim}
clone(child_stack=NULL,
      flags=CLONE_CHILD_CLEARTID|CLONE_CHILD_SETTID|SIGCHLD,
      child_tidptr=0xffff993f5c50) = 9320
\end{verbatim}

Системный вызов \texttt{clone} создаёт дочерний процесс.
Отсутствие флага \texttt{CLONE\_VM} означает,
что дочерний процесс получает собственное адресное пространство.
Флаг \texttt{SIGCHLD} указывает ядру отправить сигнал
родительскому процессу после завершения дочернего.

%----------------------------------------------------------------
\subsubsection{Чтение данных из канала}

\begin{verbatim}
read(4, "6\n8\n", 1024) = 4
\end{verbatim}

Родительский процесс считывает данные из канала.
Эти данные были записаны дочерним процессом
и представляют собой результат обработки входного файла.
Ядро копирует данные из буфера канала в адресное пространство процесса.

%----------------------------------------------------------------
\subsubsection{Вывод результатов пользователю}

\begin{verbatim}
write(1, "6\n8\n", 4) = 4
\end{verbatim}

Системный вызов \texttt{write} записывает данные
в файловый дескриптор~1, соответствующий стандартному потоку вывода.
Результаты обработки становятся видимыми пользователю.

%----------------------------------------------------------------
\subsubsection{Синхронизация и завершение}

\begin{verbatim}
wait4(9320, [{WIFEXITED(s) && WEXITSTATUS(s) == 0}], 0, NULL) = 9320
exit_group(0)
\end{verbatim}

Вызов \texttt{wait4} блокирует родительский процесс
до завершения дочернего. Ядро возвращает код завершения,
что подтверждает корректное выполнение дочернего процесса.
\texttt{exit\_group} завершает выполнение программы,
освобождая все ресурсы.

%================================================================
\subsection{Лабораторная работа №2}
\textbf{(Многопоточность, файл \texttt{log2.txt}, вариант 9)}

%----------------------------------------------------------------
\subsubsection{Ввод параметров вычислений}

\begin{verbatim}
read(0, "4\n", 1024) = 2
read(0, "3\n", 1024) = 2
\end{verbatim}

Программа считывает размер матрицы и количество потоков
из стандартного ввода. Эти параметры управляют
параллельным выполнением алгоритма.

%----------------------------------------------------------------
\subsubsection{Создание потоков}

\begin{verbatim}
clone3({flags=CLONE_VM|CLONE_FS|CLONE_FILES|CLONE_SIGHAND|
        CLONE_THREAD|CLONE_SYSVSEM|CLONE_SETTLS|
        CLONE_PARENT_SETTID|CLONE_CHILD_CLEARTID,
        child_tid=0xffff8554f230,
        parent_tid=0xffff8554f230,
        exit_signal=0,
        stack=0xffff84d40000,
        stack_size=0x80ea40,
        tls=0xffff8554f880}) = 5067
\end{verbatim}

Системный вызов \texttt{clone3} создаёт поток выполнения.
Флаг \texttt{CLONE\_THREAD} указывает, что поток
работает в рамках одного процесса,
а \texttt{CLONE\_VM} означает общее адресное пространство.
Это позволяет потокам совместно использовать данные матрицы.

%----------------------------------------------------------------
\subsubsection{Синхронизация потоков}

\begin{verbatim}
futex(0xffff85a737dc, FUTEX_WAKE_PRIVATE, 2147483647) = 0
\end{verbatim}

Вызов \texttt{futex} используется для пробуждения потоков,
ожидающих завершения вычислений.
Этот механизм лежит в основе реализации мьютексов
и условных переменных в Linux.

%----------------------------------------------------------------
\subsubsection{Завершение программы}

\begin{verbatim}
exit_group(0)
\end{verbatim}

Главный поток завершает выполнение программы,
что приводит к завершению всех потоков процесса.

%================================================================
\subsection{Лабораторная работа №3}
\textbf{(Отображаемые файлы, файл \texttt{log3.txt}, вариант 10)}

%----------------------------------------------------------------
\subsubsection{Создание файла}

\begin{verbatim}
openat(AT_FDCWD, "mapping.bin", O_RDWR|O_CREAT|O_TRUNC, 0666) = 4
ftruncate(4, 8) = 0
\end{verbatim}

Файл создаётся и приводится к фиксированному размеру.
Он используется как разделяемая область памяти
между процессами.

%----------------------------------------------------------------
\subsubsection{Отображение файла в память}

\begin{verbatim}
mmap(NULL, 8, PROT_READ|PROT_WRITE, MAP_SHARED, 4, 0)
\end{verbatim}

Вызов \texttt{mmap} отображает файл в виртуальное адресное пространство.
Флаг \texttt{MAP\_SHARED} гарантирует,
что изменения будут видны всем процессам.

%----------------------------------------------------------------
\subsubsection{Синхронизация и очистка}

\begin{verbatim}
clock_nanosleep(CLOCK_REALTIME, ...)
munmap(...)
unlinkat(AT_FDCWD, "mapping.bin", 0)
\end{verbatim}

Производится задержка для упорядочивания доступа,
после чего отображение памяти удаляется,
а временный файл уничтожается.

%================================================================
\subsection{Лабораторная работа №4}
\textbf{(Динамические библиотеки, файлы \texttt{log4.txt}, \texttt{log5.txt}, вариант 31)}

%----------------------------------------------------------------
\subsubsection{Загрузка библиотеки при запуске (program1)}

\begin{verbatim}
openat(AT_FDCWD,
       "/home/albert/mai_os_3s/lab4/code/build/libimpl_first.so",
       O_RDONLY|O_CLOEXEC) = 3
mmap(0xffff85060000, 131112,
     PROT_READ|PROT_EXEC,
     MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 3, 0)
\end{verbatim}

Динамическая библиотека загружается загрузчиком ОС
и отображается в память с правами на исполнение кода.

%----------------------------------------------------------------
\subsubsection{Вызов функций библиотеки}

\begin{verbatim}
read(0, "1 2\n", 8191) = 4
write(1, "2.2500000000\n", 13) = 13
read(0, "2 3 4\n", 8191) = 6
write(1, "12.0000000000\n", 14) = 14
\end{verbatim}

Программа принимает команды пользователя,
вызывает соответствующие функции из библиотеки
и выводит результаты вычислений.

%----------------------------------------------------------------
\subsubsection{Динамическая загрузка библиотек (program2)}

\begin{verbatim}
openat(AT_FDCWD, "./libimpl_first.so", O_RDONLY|O_CLOEXEC) = 3
openat(AT_FDCWD, "./libimpl_second.so", O_RDONLY|O_CLOEXEC) = 3
\end{verbatim}

Обе библиотеки загружаются во время выполнения программы,
что позволяет переключать реализации функций.

%----------------------------------------------------------------
\subsubsection{Переключение реализации}

\begin{verbatim}
read(0, "0\n", 8191) = 2
write(1, "switched\n", 9) = 9
\end{verbatim}

Команда пользователя инициирует смену активной библиотеки.

%----------------------------------------------------------------
\subsubsection{Повторные вызовы функций}

\begin{verbatim}
read(0, "1 2\n", 8191) = 4
write(1, "2.5000000000\n", 13) = 13
read(0, "2 3 4\n", 8191) = 6
write(1, "6.0000000000\n", 13) = 13
\end{verbatim}

После переключения используются функции из другой реализации,
что подтверждается изменением результатов вычислений.
